<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读《HTTP图解》-Chapt 2]]></title>
    <url>%2F2019%2F03%2F11%2F%E8%AF%BB%E3%80%8AHTTP%E5%9B%BE%E8%A7%A3%E3%80%8B-Chapt-2%2F</url>
    <content type="text"><![CDATA[第二章 简单的HTTP协议主要讲解HTTP的请求和响应报文;HTTP请求方法;持久链接和管线化;HTTP使用Cookie进行状态管理。 第二章 简单的HTTP协议 HTTP请求和响应报文结构请求URI(e.g./form/entry)、协议版本(e.g.HTTP/1.1)、可选的请求首部字段(e.g.Host:/Connection等)、内容实体(e.g.name=ueno&amp;age=7?) HTTP响应报文基本结构：协议版本(e.g.HTTP/1.1)、状态码(e.g.)、用以解释状态码的原因短语(e.g.)、可选的响应首部字段以及实体主体(e.g.) HTTP请求方法以前经常用到是POST、GET方法，其实HTTP/1.0总共支持10种方法： 方法 优缺点 POST、GET HEAD PUT、DELETE 不带验证机制，不安全 OPTIONS TRACE 容易引起跨站追踪攻击 CONNECT 主要使用SSLa需要经过网络隧道传输 LINK、UNLINK 已经被HTTP/1.1废弃 持久化连接HTTP协议初始，每进行一次HTTP通信就断开一次。持久连接，减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器端负载。同时，减少开销的那部分时间，使得HTTP请求和响应更快，WEB页面的显示速度提高。管线化，同时并行发送多个请求。 状态管理Cookie—一笔带过Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。比如登录认证。HTTP是无状态协议。无法根据之前的状态进行本次的请求处理。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Next 主页以及侧边栏头像旋转]]></title>
    <url>%2F2019%2F03%2F08%2FHexo-Next-%E4%B8%BB%E9%A1%B5%E4%BB%A5%E5%8F%8A%E4%BE%A7%E8%BE%B9%E6%A0%8F%E5%A4%B4%E5%83%8F%E6%97%8B%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[最近优化自己的博客，换了个NexT主题。使用的是NexT主题的Muse样式。我的博客在进行了NexT主题的安装和常规设置成功之后。这里讲解如何在首页author上方显示圆形头像，在鼠标放上的时候头像进行旋转以及侧边栏头像的圆形和旋转设置。 主页显示头像 主页设置显示头像Muse样式默认主页是不显示头型的，只显示作者、简介和菜单。打开主题配置文件Blog—&gt;themes—&gt;next—&gt;_config.yml，找到custom_logo字段1.1 打开主页header上头像的显示，将enabled设为true.1.2 image必须是图片的网络地址实现了头像显示 现在首页头部显示头像是正方形的，根据字段custom-logo，找到NexT主题关于custom-logo的设置。发现了_logo.styl文件，目录为Blog—&gt;themes—&gt;next—&gt;source—&gt;css—&gt;_schemes—&gt;Muse—&gt;_logo.styl要实现圆形显示，而且实现旋转效果。对于构建网页来说，CSS文件是控制网页内容如何显示的。打开_logo.styl文件，发现custom-logo-image字段，猜测应该就是对应头像了，增加对于头像custom-logo-image的设置。添加代码如下代码即可 1234567891011121314.custom-logo-image &#123; margin: 0 auto; padding: 5px; max-width: 150px; background: white; /* start*/ border-radius: 50% #头像圆角 transition: 2.5s all; #旋转动画时间&#125;.custom-logo-image:hover &#123; transform: rotate(360deg); #旋转角度&#125;/* end */ 在Blog目录重启服务即可实现。最终实现效果展示： 侧边栏头像旋转 侧边栏显示的头像设置成圆形，并且鼠标滑过头像旋转的设置和主页的头像设置差不多。进入CSS文件，找到关于sidebar中关于作者的设置文件。NexT主题关于sidebar的基础设置位于文件夹_common中，改变此文件夹内文件，会改变所有主题的相对应设置。 打开Blog—&gt;themes—&gt;next—&gt;source—&gt;css—&gt;_common—&gt;components—&gt;sidebar—&gt;sidebar-author.styl 修改关于.site-author-image的设置，改成如下代码 1234567891011121314151617.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* start*/ border-radius: 60% transition: 2.5s all;&#125;.site-author-image:hover &#123; background-color: #55DAE1; #背景颜色 transform: rotate(360deg);&#125;/* end */ 重新启动服务器Blog:hexo s]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《HTTP图解》-Chapt 1]]></title>
    <url>%2F2019%2F03%2F06%2F%E8%AF%BB%E3%80%8AHTTP%E5%9B%BE%E8%A7%A3%E3%80%8B-Chapt-1%2F</url>
    <content type="text"><![CDATA[因为是第一次认真的写读书笔记，不知道如何写起，就以《HTTP图解》的书本目录大概回忆总结一下。 第一章 了解Web及网络基础：主要讲解了TCP/IP协议族的分层管理以及各分层与HTTP关系密切的协议概念，URI和URL的区别以及定义 第一章 了解Web及网络基础 1.1 使用HTTP协议访问Web 发送HTTP请求 1.2 网络基础TCP/IP 1.3 与HTTP关系密切的IP、TCP和DNS协议以及各种协议与HTTP协议的关系 DNS服务提供域名到IP地址之间的解析服务。域名是让我们凡人看的，IP地址是一长串纯数字，较为复杂不好记，DNS服务将主机名.域名对应的IP地址找到然后传给计算机处理。 TCP提供可靠的字节流服务。三次握手，确保数据准确无误到达目标。 IP协议的作用是把数据包安全传送给对方。 1.4 URL和URI URI：统一资源标识符URL：统一资源定位符 我认为URI是资源访问协议中所有资源的某个资源地址，而URL是指向该资源目标的指针。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-地址URL判断]]></title>
    <url>%2F2019%2F02%2F27%2FiOS-%E5%9C%B0%E5%9D%80URL%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[为什么要做这件事最近公司需要一个自定义后台URL，使用常规的网上的判断网络地址URL正则表达是总是判断不准确。经过多方求证，发现苹果对一些常用的正则匹配都作了封装，如时间、时区、网页链接url、电话号码等等。而且这些识别是国际化的，比如中国的手机号是13044345467，XX国的手机号是932-23333222，它都可以识别。又比如中国人的名字是王大锤，英国人的名字是 William Jafferson Clinton，也都能识别。举例： 验证URL方法 常规出现错误示例 匹配网址URL的正则表达式：[a-zA-z]+://[^\s] 12345//判断地址是否正确- (BOOL)verifyWebUrlAddress:(NSString *)webUrl&#123; return [webUrl isMatchWithRegexString:@&quot;[a-zA-z]+://[^\s]*&quot;];&#125; 出现问题： URL地址中不能存在s，否则返回NO 因为本人目前对于正则表达的博大精深只理解了些皮毛，不知道作何修改，这时候发现了苹果对一些常用的正则匹配都作了封装，喜不自胜。 苹果对一些常用的正则匹配作了封装示例 不用自己去写正则表达式匹配采用系统类NSDataDetector。 123456789101112131415161718192021//判断地址是否正确- (BOOL)verifyWebUrlAddress:(NSString *)webUrl&#123; NSError *error = nil; NSDataDetector *detector = [NSDataDetector dataDetectorWithTypes:NSTextCheckingTypeLink error:&amp;error]; NSArray *matches = [detector matchesInString:webUrl options:nil range:NSMakeRange(0, webUrl.length)]; if (matches.count == 1) &#123; NSTextCheckingResult *result = matches.firstObject; if (result.range.location == 0) &#123; return YES; &#125; else &#123; return NO; &#125; &#125; else &#123; return NO; &#125;&#125; 不过，在查找方法过程中，发现验证URL链接更简单的办法我们还可以借助系统提供的 canOpenURL() 方法来检测一个链接的有效性，比如上面样例可以改成如下的判断方式： 12345678//判断地址是否正确- (BOOL)verifyWebUrlAddress:(NSString *)webUrl&#123; if (!webUrl) &#123; return NO; &#125; return [UIApplication.sharedApplication canOpenURL:[NSURL URLWithString:webUrl]];&#125; NSDataDetector的详细使用方法]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Q&A | 苹果官方新规定之隐私条款]]></title>
    <url>%2F2018%2F11%2F01%2FQ-A-%E8%8B%B9%E6%9E%9C%E5%AE%98%E6%96%B9%E6%96%B0%E8%A7%84%E5%AE%9A%E4%B9%8B%E9%9A%90%E7%A7%81%E6%9D%A1%E6%AC%BE%2F</url>
    <content type="text"><![CDATA[今天看到苹果新出了这个规定，就赶紧搜索搜索了之后，发现这篇文章说的是比较全面的 原文Q&amp;A | 苹果官方新规定之隐私条款 最近两天各位CP都因友盟的这个提示有点慌，具体内容如下： 亲爱的客户： 您好！ 从2018年10月3日开始，App Store Connect将要求所有新应用和应用更新版本时提供隐私政策，添加后才可以在App Store上提交或通过TestFlight外部测试进行分发。苹果通知： As a reminder, in June the App Store Review Guidelines were updated to require a privacy policy for all new apps and app updates as part of the app review process. Starting October 3, 2018, App Store Connect will require a privacy policy for all new apps and app updates before they can be submitted for distribution on the App Store or through TestFlight external testing. In addition, your app’s privacy policy link or text will only be editable when you submit a new version of your app.（详情可参见：参见：Privacy Policy Reminder - News - Apple Developer） 所以，在此提醒各位开发者：提交App Store 审核前一定要准备自己的隐私权政策，并在app SafariViewContoller中弹出，否则会无法通过审核哦！ 范本提供：为便于一些开发者准备隐私权政策的条款，我们已起草了一份隐私权政策的中文版本，开发者可根据自己的业务场景进行修改，点击可下载隐私权政策范本 苹果隐私条款。 以上范本仅供各位开发者参考，如需要专业的法律意见，还请各位开发者小伙伴咨询您的律师或法律顾问哦！ 实际在今年8月份的时候，苹果就发了通知，具体如下: 近期又发了一条，再一次提醒： 看到这些提示后，很多人会产生以下几个问题： Q: 现在是必须要提交这个隐私政策的网站吗？ A: 是的，必须提交。在下面截图中显示的地方提交： Q: 是用户下载打开APP的时候，有弹框提示，让用户点击后知道隐私内容吗？ A: 是的，弹框提示样式如下： Q: 对APP的要求是必须强制弹框吗？ A: 苹果官方只是要求加上一个访问隐私政策入口，并没有要求一定要强制弹窗。 其实关于隐私政策的问题，早在苹果在iOS12的发布前，就特意提到，在IOS12中，会进一步加大隐私保护力度，同时safari浏览器还会阻止广告商收集你设备的信息。 但这个问题不会给审核带来很大的困扰，添加一个隐私链接就可以解决，隐私政策文本在网络上随处能够找到，根据自己的情况修改一下就可以了。（也可以尝试直接去看网易、腾讯的隐私链接，扒过来略加修改就好） 最后，再添加一些其他内容 隐私政策除了在App Store Connect的隐私政策url写上链接，还需要在APP里添加一个按钮链接到这个url,如果是内购还需要在你的内购页面添加一个按钮是用户可以看到这个内容,可以是静态的非联网。可以参考抖音隐私政策。 使用SafariViewContoller 1234567891011121314151617// 导入SafariServices.h#import &lt;SafariServices/SafariServices.h&gt;// 设置代理@interface VC1 ()&lt;SFSafariViewControllerDelegate&gt;@end// 点击使用- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; // 输入项目的隐私政策的 URL SFSafariViewController *sfVC = [[SFSafariViewController alloc]initWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com/#privacy&quot;]]; sfVC.delegate = self; [self.navigationController presentViewController:sfVC animated:YES completion:nil];&#125;# pragma# pragma mark - SFSafariViewControllerDelegate -- (void)safariViewControllerDidFinish:(SFSafariViewController *)controller&#123; NSLog(@&quot;点击done&quot;);&#125; 最后提及一个点，关于应用内部是否需要展示隐私政策这个点，目前苹果是没有强制要求。有是最好的，锦上添花。目前内部展示参考今日头条，下载完成之后第一次进入应用就弹出政策该要，需要用户同意，同时在用户注册界面也有勾选项。也有像饿了么这样，隐私政策必须要同意，不然只能点击退出。。。 iOS隐私政策模板iOS隐私政策]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode-10和iOS-12排雷]]></title>
    <url>%2F2018%2F09%2F19%2FXcode-10%E5%92%8CiOS-12%E6%8E%92%E9%9B%B7%2F</url>
    <content type="text"><![CDATA[今天刚升级到Xcode10，迫不及待运行项目，结果1S我就回到冰点，爆红点。网查发现解决方案。网查的时候发现还有个问题似乎出现概率也挺高的，我就汇总一下，节省之后可能浪费的时间。 雷区一、二是我自己出现的问题，其他还没有实测，如果没有解决你的问题，请自行找度娘。 雷区一：Multiple commands produce123error: Multiple commands produce &apos;/Users/xiaoyuan/Library/Developer/Xcode/DerivedData/Boobuz-gnxeuntgkenwgdgycqnvabqubafh/Build/Products/Debug-iphoneos/Boobuz.app&apos;:1) Target &apos;Boobuz&apos; has create directory command with output &apos;/Users/xiaoyuan/Library/Developer/Xcode/DerivedData/Boobuz-gnxeuntgkenwgdgycqnvabqubafh/Build/Products/Debug-iphoneos/Boobuz.app&apos;2) That command depends on command in Target &apos;Boobuz&apos;: script phase “[CP] Copy Pods Resources” 分析error内容，错误发生在Copy Pods Resources，而且与output有关，应该是使用了cocoapods导致的，尝试删除该项目target-Copy Pods Resources-Output Files，成功解决问题。参考解决方案：Xcode 10 beta3 Error: Multiple commands produce 雷区二 12ld: library not found for -lstdc++.6.0.9clang: error: linker command failed with exit code 1 (use -v to see invocation) 项目用到了c++，依赖了libstdc++.6.0.9.tbd,导致整个工程编译不通过，原因是苹果在XCode10和iOS12中移除了libstdc++这个库，由libc++这个库取而代之,苹果的解释是libstdc++已经标记为废弃有5年了，建议大家使用经过了llvm优化过并且全面支持C++11的libc++库。“libc++” C++ Standard Librarylibc++和libstdc++接下来更新这个库就好了，TARGETS—&gt;Build Phases—&gt;Link Binary With Libraries()直接删除，然后添加libc++解决。更多详情查看Xcode10和iOS12适配查找答案的时候发现报错ld: library not found for -lxxxx-ios-x.x.x之类的，可能在合并或者其他操作的时候，误删了这个库，试试在这个路径添加喽。 雷区三123:-1: Multiple commands produce &apos;/Users/.../Library/Developer/Xcode/DerivedData/.../Build/Products/Dev-iphonesimulator/TLYShyNavBar/TLYShyNavBar.framework/Info.plist&apos;:1) Target &apos;TLYShyNavBar&apos; has copy command from &apos;/Users/.../Desktop/Workspace/iOS/.../Pods/TLYShyNavBar/TLYShyNavBar/Info.plist&apos; to &apos;/Users/.../Library/Developer/Xcode/DerivedData/.../Build/Products/Dev-iphonesimulator/TLYShyNavBar/TLYShyNavBar.framework/Info.plist&apos;2) Target &apos;TLYShyNavBar&apos; has process command with input &apos;/Users/.../Desktop/Workspace/iOS/.../Pods/Target Support Files/TLYShyNavBar/Info.plist&apos; In Xcode, go to File-&gt;Project/Workspace settings. Change the build system to Legacy Build system.参考解决方案：Xcode10 Multiple commands produced error 雷区四这个项目中并未用到，直接删除了文件。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-适配-iPhone-X、XR、XS、XS-Max]]></title>
    <url>%2F2018%2F09%2F19%2FiOS-%E9%80%82%E9%85%8D-iPhone-X%E3%80%81XR%E3%80%81XS%E3%80%81XS-Max%2F</url>
    <content type="text"><![CDATA[iOS 判断机型是否为 iPhone X、XR、XS、XS Max 的方法1234567891011if ([deviceString isEqualToString:@&quot;iPhone10,1&quot;]) return @&quot;国行(A1863)、日行(A1906)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,4&quot;]) return @&quot;美版(Global/A1905)iPhone 8&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,2&quot;]) return @&quot;国行(A1864)、日行(A1898)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,5&quot;]) return @&quot;美版(Global/A1897)iPhone 8 Plus&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,3&quot;]) return @&quot;国行(A1865)、日行(A1902)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone10,6&quot;]) return @&quot;美版(Global/A1901)iPhone X&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,2&quot;]) return @&quot;iPhone XS&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,4&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,6&quot;]) return @&quot;iPhone XS Max&quot;;if ([deviceString isEqualToString:@&quot;iPhone11,8&quot;]) return @&quot;iPhone XR&quot;; 参考原文:史上最全的iOS各种设备信息获取总结 信息采集框架iPhone XR/iPhone XS Max启动图iPhone XR：828px x 1792pxiPhone XS Max: 1242px x 2688px 代码中判断是否是iPhone X时需要注意如果你以前是使用设备尺寸来判断iPhone X那就需要修改了，判断iPhone X主要是因为刘海的原因可能要做些特殊处理。鉴于iPhone X/XS/XR/XS Max底部都会有安全距离，所以可以利用safeAreaInsets.bottom &gt; 0.0来判断是否是iPhone X/XS/XR/XS Max。 safeAreaInsets支持iOS11及以后。 1#define IPHONE_X (@available(iOS 11.0, *)?[[[UIApplication sharedApplication] delegate] window].safeAreaInsets.bottom &gt; 0.0:NO ) 参考原文:适配iPhone XR/iPhone XS Max]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLCipher]]></title>
    <url>%2F2018%2F09%2F19%2FSQLCipher%2F</url>
    <content type="text"><![CDATA[转自使用SQLCipher加密SQLite数据库其他参考文章： 集成SQLCipher SQLite 加密 – SQLCipher 在iOS应用程序开发中经常需要使用SQLite来存储数据，很多时候需要加密保存一部分的数据。常见的做法是将要存储的内容先加密然后存到数据库中，使用的时候将数据进行解密，这样就会有大量的性能消耗在数据的加解密上（性能主要取决于加解密的算法和CPU的能力）。 SQLCipher is an open source extension to SQLite that provides transparent 256-bit AES encryption of database files. SQLite本身是支持加密功能的（免费版本不提供加密功能，商业版本是支持加密模块）。SQLCipher是一个开源的SQLite加密扩展，支持对db文件进行256位的AES加密。 集成SQLCipher集成SQLCipher有有两种方法一种是按照官方的方式一步步的执行，这里就不过多的介绍。配置过程很麻烦，推荐使用下面的方式集成。 1、获取SQLite加密模块(SQLCipher) 在终端(Terminal)中使用pod search FMDB，在查询的结果中可以看到有个FMDB/SQLCipher的Sub spec。 如果使用FMDB和CocoaPods的话直接在你的Podfile中添加pod &#39;FMDB/SQLCipher&#39; 如果没有使用CocoaPods的话建议还是安装一个吧，或者是新建一个测试项目安装FMDB和SQLCipher。安装CocoaPods可以参考《使用CocoaPods管理iOS项目中的依赖库》 2、导入SQLCipher 执行pod install之后会自动获取SQLCipher，其实SQLCipher只有两个文件sqlite3.h和sqlite3.m。 拷贝sqlite3.h/sqlite3.m文件到项目中，如果使用CocoaPods方式获取SQLCipher的话，这一步骤就不需要了。 3、配置Xcode设置项 通过查询资料SQLite是否开启加密模块是通过宏(SQLITE_HAS_CODEC)来配置的。那么就需要在Xcode中配置开启SQLite加密组件的宏（如使用CocoaPods方式则不需要配置）。 (1)target –&gt; Build Setting –&gt; Other C Flags添加-DSQLITE_HAS_CODEC配置 (2)target –&gt; Build Setting –&gt; Other Linker Flags添加-framework Security配置 4、如何使用 (1)引入sqlite3加密模块，然后在打开数据库之后加入如下代码 |12 |12const char *key = [@&quot;devzeng&quot; UTF8String];sqlite3_key(_db, key, (int)strlen(key)); | 如下图： 说明： 1）如果没有添加-DSQLITE_HAS_CODEC配置上面的代码会报错 2）sqlite3_key函数需要指定加密使用的key，推荐使用UUID(可以进行salt处理)并存储到KeyChain中。 3）如使用FMDB，可以在FMDB的open方法之后添加上面的两行代码。 (2)使用了加密模块在提交到App Store时需要指明，具体的操作方法可以参考StackOverflow上面的做法。 Does my application “contain encryption”? 参考资料1、《Adding SQLCipher to Xcode Projects》 2、《ios开发FMDB导入SQLCipher加密数据库》 3、《SQLite数据库加密研究》]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[全面的-gitignore模板集合]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%85%A8%E9%9D%A2%E7%9A%84-gitignore%E6%A8%A1%E6%9D%BF%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[对于不同的编程语言、不同的编译系统、不同的构建工具，很难找到所有需要添加ignore的文件，经常会出现各种遗漏等选择性错误。如果能有一个东西，就像是一个模板，记录所有环境下的ignore信息，在需要的时候便于查询，那就太合适不过了。全面的ignore集合 原简书地址]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift4进阶]]></title>
    <url>%2F2018%2F09%2F19%2Fswift4%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Swift 4.0 教程 三十天三十个 Swift 项目 三十天三十个 Swift 项目-简书]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三言两语笔记(树结构)]]></title>
    <url>%2F2018%2F03%2F27%2F%E4%B8%89%E8%A8%80%E4%B8%A4%E8%AF%AD%E7%AC%94%E8%AE%B0-%E6%A0%91%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[背景：最近后台决定传给我一个树结构的json数据，每个子节点有目录结构，类似0001 0001要求： 以列表的方式展示分组，能够折叠展开 当传过来的叶子节点为可编辑并且有值时，需要其结构上的父节点的值相对改变(增加或者减少) 当改变叶子节点的值时，父节点的值需要层层改变。 最初想法与实现： tableview列表需要有一组数据 既然要根据子节点改变父节点的值，需要把树结构的所有子节点放入一个数组中进行遍历。遍历存入数组时，，先存储根节点，每一层都可作为根节点，然后存储下一层节点，进而下一层节点即为根节点数组，以此循环。同时把可编辑节点目录存入一个数组3.根据可编辑节点数组，截取节点的上级节点目录，去遍历存储所有节点数组，依次改变值 存在问题： 需要进行多次do…while循环，费时占内存，界面已经加载，数据突然改变的问题 tableview列表的数据，因为刚开始没有展开，所以只存储了根节点，把根节点的子节点付给cell，点击展开的时候，把子节点插入列表数组。但之后发现根节点可能也需要根据可编辑子节点已有的值进行值的改变。每进行一次折叠、展开，都需要去所有数组中查询节点的值，很伤，很晕 反思：把所有数据存入字典中，像一个hash表，当然刚开始的循环存入所有节点的步骤不能省。把节点目录最为key，把节点作为value存入字典。 优点： 当改变某一节点值，只需要截取改节点目录，查找上级节点目录，作为key，直接取出节点，不要遍历数组 进行tableview的折叠展开，只需要在数组中存储节点，再根据节点目录查找真正的显示值即可。 条理清晰，可扩展性强。 我有酒，你有工作吗？来，坐下来谈谈。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取经-封装库]]></title>
    <url>%2F2018%2F03%2F20%2F%E5%8F%96%E7%BB%8F-%E5%B0%81%E8%A3%85%E5%BA%93%2F</url>
    <content type="text"><![CDATA[公司最近需求：完整版的项目代码需要给别人使用，但是不希望别人看到源码解答：需要以库的形式进行封装，只暴露出头文件语言背景：Object-C记录封装库的历程吧，希望一路顺畅😂 查看了一下静态库，动态库与 Framework的定义区别。——&gt;需要把项目代码封装成静态库。 参考iOS 完整项目制作Framework 创建和使用静态库… 我的操作： 创建一个Cocoa Touch Framework 把之前除了appdelegate以及ViewController等项目文件导入工程。 自己动手创建静态库粗线的问题： 如果直接封装静态库Cocoa Touch Static Library，后缀为.a。项目中使用了charts框架，不能识别导入charts.workspace文件 封装成Cocoa Touch Framework。 OC类中找不到charts中的文件 预编译一下，在Products中，右键单击 项目.framework，在Header文件夹中找到 项目-Swift.h，这个文件中包含有swift的全部类，导入工程中。(摸索中，不知道凑效不) 之前写入.pch文件，可以预编译的类，不能使用了 在报错的文件中导入需要的文件类。这样太麻烦了，有可能是我对封装过程理解的不够。之后后话吧/(ㄒoㄒ)/~~ 最头痛的问题：由于framework里边不能导入APPdelegate，所以之前在APPdelegate中的属性不能使用，有关跳转到根目录的操作不能完成。现在还没有解决方法。 原因：由于打包类库工程不是一个完整项目工程，所以并没有AppDelegate等文件，所以涉及到这些的文件要额外处理，或改代码，或适当改变功能。]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS环信即时通讯云遇到的坑]]></title>
    <url>%2F2018%2F03%2F07%2FiOS%E7%8E%AF%E4%BF%A1%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E4%BA%91%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[最近因为要找工作，写简历的时候，写到环信即时通讯云，突然忘记了当时自己入的坑是啥了，所以赶紧记录一下，烂笔头还是挺好的。项目需要继承环信即时通讯云到项目，当然首要工作就是查看官方文档&lt;&lt; 访问 环信即时通讯云开发文档 巴拉巴拉巴拉~~~在此不赘述了，这里只记录坑：填坑一、快速集成iOS SDK，我这里用的pods进行第三方框架管理 方法一:pod ‘EaseUILite’, :git =&gt;’https://github.com/easemob/easeui-ios-hyphenate-cocoapods.git‘ 我按着这个写了，结果就出现了问题，告诉我一个什么image文件找不到了，几经周折，看EaseUILite的版本，发现默认是最近的版本3.3.8好像，最后试着降低一个版本，就好了😂。当时挺苦恼的。 据说这个EaseUILite还好, 在swift项目中集成EaseUI坑好像更大，以后试试 填坑二、pod下方有个小注意，当时就忽略了 注意： EaseUI:对应Hyphenate SDK（sdk包含实时音视频） EaseUILite:对应HyphenateLite SDK(sdk不包含实时音视频) Pod集成EaseUI时，会同时通过Pod集成SDK 刚开始读文档有点晕，此坑为小小坑 其他有些不记得了，欢迎补充交流。最后祝自己能找到一份好工作。🎉附GitHub主页Gitee主页]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 iOS企业证书的申请]]></title>
    <url>%2F2017%2F09%2F22%2F2017-iOS%E4%BC%81%E4%B8%9A%E8%AF%81%E4%B9%A6%E7%9A%84%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[网上查了许多关于企业证书申请的流程，都不完整或者不正确，很不满意，所以自己动手写了一个我申请企业证书的流程以供参考 本文介绍 ​ 因为简书介绍申请Apple ID步骤、申请邓白氏编码步骤的文章很多，而且都是一样的，我在文章中就不赘述了。 本文主要包括以下几个方面： 申请企业账号的准备工作 正式申请企业账号 制作企业证书 这里需要注意： 企业账号的作用：企业账号是苹果给企业用户用来进行内部测试用的一种账号，我们可以通过该账号生成的证书打包APP，放于企业的内部网站上（不可上传AppStore），可供苹果用户下载安装，不过值得注意的是通过这种方式安装APP，一旦账号一年有效期到期，手机上已经安装的APP无法启动，也无法在网站上下载安装，必须重新打包发布。因此账号按期续费非常重要。此证书主要是没有安装设备数量限制（由于此特点，在测试和分发 App 时，给开发者带来了极大的便利，尤其是多人协作）。但是要注意：此账号仅仅用于内部测试，不可公开下载，苹果的管控是非常严格的，任何违背苹果条款使用企业账号，都会有企业账号被封的风险，封号之后使用该证书的APP将会闪退。 开始 申请企业账号的准备工作 如果已有的Apple ID已经申请过公司开发者证书的，需要重新注册一个以企业公共网址域名为后缀的邮箱，以该邮箱注册新的Apple ID。 例如公司网址域名后缀xxx.com，邮箱后缀xxx.com需要保持一致，现在苹果对苹果开发者证书审核很严格，不小心就容易被拒。 企业邮箱注册成功，即可申请苹果企业账号了。 正式申请企业账号 用❤新注册的Apple ID登录苹果官网，进入首页。滑动到页面最下方，点击左侧第一列的Developer Program，如下图所示： 点击进入Apple Developer Program界面，继续滑动到页面最下方，点击Enterprise Program，如下图所示： 可以进行注册了，点击Enroll，如下图所示： 选择为Company/Organization，然后点击Continue，继续 ​ 看下面的英文你可以看出上面的意思是你是一个公司的所有制。下面的意思是你被授权做这件事。所以我很自然的选择了下面 选择之后你需要填写以下信息 填写申请相关信息：邮箱内收到的邓白氏编码、公司英文名、公司主页网址、总部座机、工作邮箱，最后如果你是移动设备商，需要勾选最后的小框。其中，总部电话Country Code填写86，Phone Number填写公司座机号（前面加区号），Extension填写分机号。例：86-3299XXXXXXXX-XXX。邮箱后缀xxx.com和公司网址域名后缀xxx.com需要保持一致，现在苹果对苹果开发者证书审核很严格，不小心就容易被拒。填写完后，点击“Continue”。 公司人员选择项 点击蓝色按钮Continue之后，会提示“Your enrollment is being processed”，说明开发者证书申请已经提交。好吧，接下来又是等了，大概一天左右。如果申请期间，因为资料缺失或准备不完整，造成审核退回，发送撤回原因到你的申请邮箱，并可以联系苹果公司4006 701 855。如果需要更新邓白氏的资料，可以发送邮件至邓白氏（若需要邓白氏协助，一般苹果回复的邮件里含有邓白氏公司的邮件地址），可以用中文或英文撰写邮件。 这里需要注意：如果联系苹果公司，需要你是项目主管理人员，否则你可能会被告知请让你的领导来打电话吧，否则我不会告诉你撤回原因的 ​ 声明：下面这几步我没经历过，都是老板付钱，所以图片都是网上下载的，原著勿怪勿怪 正常的话大概一两天就可以收到苹果公司的电话(苹果现在的办事效率是真快)，确认基本信息和用途（特别注意：公司内部测试，他会问，您的客户会参加测试吗？答案当然是NO!），然后会收到可以继续的邮件。打开邮件的链接或者登录网站，即可继续申请。首先，同意一下协议。点击提交。 点击购买。Apple Developer Enterprise Program证书需要的费用为人民币￥1988。 选择付款方式 付款完成。邮箱会收到订单邮件，这时就可以使用苹果证书了，后面快到期的时候记得续缴费用。 制作企业证书 sdfsafa sdfdsgaf sfsafa]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[被苹果拒绝了]]></title>
    <url>%2F2017%2F05%2F10%2F%E8%A2%AB%E8%8B%B9%E6%9E%9C%E6%8B%92%E7%BB%9D%E4%BA%86%2F</url>
    <content type="text"><![CDATA[If someone has to take the tough stuff, let me do it. ——地藏王菩萨 ​ 第一次上线应用到App Store，虽然 之前也参考了很多上架文档，但都没有自己上架被拒来的印象更深刻、更痛😂 错误描述 Design Preamble Your app includes an update button or alerts the user to update the app. To avoid user confusion, app version updates must utilize the iOS built-in update mechanism. Please see attached screenshots for details. 简言之，就是APP里有软件版本更新的提示以及相关操作 建议解决方案 To resolve this issue, please remove the update feature from your app. To distribute a new version of your app, upload the new app binary version into the same iTunes Connect record you created for the app’s previous version. Updated versions keep the same Apple ID, iTunes Connect ID (SKU), and bundle ID as the original version, and are available free to customers who purchased a previous version. 解决方案，删除更新操作，bulabulabula,,,然后给你一个APP错误截图 错误描述 如果没用到IDFA，就注释掉那段代码吧，省的提交的时候还要提交其他的文件 错误描述 Guideline 2.1 - Performance - App Completeness We discovered one or more bugs in your app when reviewed on iPad running iOS 10.3.2 on Wi-Fi connected to an IPv6 network. Specifically, the demo account that you provided does not contain any content. Please provide a demo account that provides content. 我去，竟然说我没内容，NND不知道点一下试试吗？就是点一下有个验证，验证完就有了！！！！😂 建议解决方案 To resolve this issue, please run your app on a device while connected to an IPv6 network (all apps must support IPv6) to identify any issues, then revise and resubmit your app for review. If we misunderstood the intended behavior of your app, please reply to this message in Resolution Center to provide information on how these features were intended to work. For new apps, uninstall all previous versions of your app from a device, then install and follow the steps to reproduce the issue. For updates, install the new version as an update to the previous version, then follow the steps to reproduce the issue. 解决方案，连不上网络，NND我又试了试没问题啊，不会是后台更新服务那会儿吧，背/(ㄒoㄒ)/~~ 小插曲：这次因为苹果莫须有的原因被拒，我直接又提交审核了，之后才知道，TMD竟然有申诉，申诉比再次提交审核快多了。长记性！！！ 错误描述 Guideline 2.3.8 - Performance - Accurate Metadata We noticed the app icon displayed on the device and the large icon displayed on the App Store do not sufficiently match, which makes it difficult for users to find the app they just downloaded. Please see attached screenshots for details. 意思是，应用运行后展示图标和提交审核上传的App图标不一致 建议解决方案 To resolve this issue, please update the smaller device icon to match the larger App Store icon. When users search for your app on their devices, they should be able to recognize it from the icon on the App Store. Resources Since the large app icon will be displayed for your app on the desktop App Store, we recommend you provide an attractive, original icon that meets the following requirements for both iPhone/iPod touch and iPad apps: - 512px square (do not scale-up smaller artwork, as this could appear pixelated and blurry) - 72ppi, RGB, flattened, no transparency - High quality JPEG,TIFF, or PNG image file format. (ZIP-compressed TIFF files are not acceptable) You can also preview image files before submitting them by clicking the filename to view them in a separate window. Note that the small icon that you include inside your app’s binary will be used on the iPhone, iPod touch, or iPad Home screen when installed. For more on icon sizes, please review App Icons on iPad and iPhone . For resources on creating eye-catching icons, you may want to review the App Store Product Page information available on the Apple developer portal. 说了这么多呢，哎，怪我，应用程序中应用图标更改了，可是忘记更改审核上传的App图标了，所以就被拒了。/(ㄒoㄒ)/~~ 错误描述 Your app contains references to test, trial, demo, beta, pre-release or other incomplete content. Specifically, your app name ****试用版 contains reference to trial (试用). 建议解决方案 To resolve this issue, please remove all references to “demo,” “trial,” “beta,” or “test” in your app description, app icon, screenshots, previews, release notes, and binary. If you would like to conduct a beta trial for your app, you may wish to review the TestFlight Beta Testing Guide. 意思就是APP名称里不能包含test, trial, demo, beta, pre-release等字眼，我以为第一版已经过了，这个已经不成问题了吧，没想到，第二版给我拒了/(ㄒoㄒ)/~~ 错误描述 建议解决方案]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
        <tag>发布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS小方法小工具]]></title>
    <url>%2F2017%2F01%2F27%2FiOS%E5%B0%8F%E6%96%B9%E6%B3%95%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[当后台传值类型为long 前端需要用NSString类型接收 当需要与特定值进行比较时，需要把该值用doubleValue转化后与数值比较，不能用NSString类型直接比较，因为后台可能传出的值为0.00型的或者0.0型的等，不能完全相等 123456Model *model = [Model alloc] init];model.userID = dict[@&quot;id&quot;];if ([model.userID doubleValue] == 0) &#123; //做需要的操作 &#125; 设置view的背景图片 1view.layer.constonts = (__bridge id)image.CGImage; 界面通常为tableView或者collocationView布局。(借鉴dzenbot/DZNEmptyDataSet) 当视图数据为空时，需显示默认视图。 可以在tableView创建的cell个数的时候判断是否有内容，如果内容为空，显示默认视图，否则移除。 待：此方法不是最优化方法，需想出更一劳永逸的解决方法。 向数组中插入多个元素 数组操作中不仅能插入一个元素，还能插入多个元素首位或者末尾 1234NSArray *addModel = @[kbOne,kbTwo];NSRange range=NSMakeRange(0, addModel.count);NSIndexSet *indexSet = [NSIndexSet indexSetWithIndexesInRange:range];[self.modelsArray insertObjects:addModel atIndexes:indexSet]; 裁剪圆形头像 123456789101112131415161718192021222324252627282930313233#pragma mark - 裁剪圆形头像- (UIImage *)imageWithClipImage:(UIImage *)image borderWidth:(CGFloat)borderW boderColor:(UIColor *)boderColor&#123; //加载image //UIImage *image = [UIImage imageNamed:imageName]; //开启位图上下文 CGSize roundSize = CGSizeMake(image.size.width + 2 * borderW, image.size.height + 2 *borderW); UIGraphicsBeginImageContextWithOptions(roundSize, NO, 0.0); UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, roundSize.width,roundSize.height)]; [boderColor set]; [path fill]; //设置裁剪区域 CGRect clipRect = CGRectMake(borderW, borderW, image.size.width, image.size.height); path = [UIBezierPath bezierPathWithOvalInRect:clipRect]; [path addClip]; //绘制图片 [image drawAtPoint:CGPointMake(borderW, borderW)]; //从上下文中取出新的图片 UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); //结束上下文 UIGraphicsEndImageContext(); //显示新图片 //self.iconImageView.image = newImage; return newImage;&#125; UIImageView旋转 12345//需要注意，这里之所以用(0.000001 - M_PI),是因为transform动画旋转会选择最近的路径进行旋转，默认是顺时针，如果直接选择- M_PI，那么箭头只会顺时针旋转，不会逆时针旋转// 使用了(0.000001 - M_PI)，那么它会选择近的路径旋转，就不会顺时针旋转了//大部分APP的下拉刷新基本都是箭头逆时针回旋，并不是一直顺时针旋转CGFloat angle = 0.000001 - M_PI ;self.headerBtn.imageView.transform = CGAffineTransformMakeRotation(angle); UIEdgeInsets和UIOffsets UIOffsetview距离父视图superView的边距 UIEdgeInsets内边距view内的content距离view的边距 UIEdgeInsets是什么？ 123typedef struct UIEdgeInsets &#123; CGFloat top, left, bottom, right; // specify amount to inset (positive) for each of the edges. values can be negative to &apos;outset&apos;&#125; UIEdgeInsets; 三个UIEdgeInsets属性 123@property(nonatomic) UIEdgeInsets contentEdgeInsets UI_APPEARANCE_SELECTOR; // default is UIEdgeInsetsZero@property(nonatomic) UIEdgeInsets titleEdgeInsets; // default is UIEdgeInsetsZero@property(nonatomic) UIEdgeInsets imageEdgeInsets; // default is UIEdgeInsetsZero 提示：UI_APPEARANCE_SELECTOR标记的属性都支持通过外观代理来定制。 举例，设置UIButton的contentEdgeInsets属性，可以直接调用： 123[[UIButton appearance] setTitleEdgeInsets:UIEdgeInsetsMake(0, 0, 0, 0)];或者 button.imageEdgeInsets ＝ UIEdgeInsetsMake(0,0,0,0); tableview的contentOffset和contentInset 123@property(nonatomic)CGPoint contentOffset; // default CGPointZero@property(nonatomic)CGSize contentSize; // default CGSizeZero@property(nonatomic)UIEdgeInsets contentInset;// default UIEdgeInsetsZero. add additional scroll area around content contentSize表示的是内容区域的大小 contentOffset 是scrollview当前显示区域顶点相对于frame顶点的偏移量，可以理解为contentview的顶点相对于scrollerVIew的frame的偏移量。 contentInset表示contentView.frame.orgin与scrollerView.frame.orgin的关系。可以类比于css里的padding。 参考contentSize、contentOffset和contentInset的图解辨别 UIButton之图片、文字 参考UIButton 的 imageEdgeInsets 和 titleEdgeInsets UIScrollerView偏移问题 12345// public var automaticallyAdjustsScrollViewInsets: Bool // Defaults to YES// 这个是scrollview自动调整.当scrollview是第一个view时,系统会自动调整,否则不会自动调整64 view.automaticallyAdjustsScrollViewInsets = false// 去掉自动调整后,我们可以手动将tableview的contentInset调整64,就能完成我们的需求 tableView.contentInset = UIEdgeInsets(top: 64, left: 0, bottom: 0, right: 0) 当有tabBarController时,推出下一个界面时,隐藏tabbar* 1hidesBottomBarWhenPushed = true HTTP类封装：判断用户权限、是否登陆操作 需要封装一个HTTP相关的类，在收到后台的初始数据时进行处理，然后再封装后传出去]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode：添加自定义代码片段]]></title>
    <url>%2F2017%2F01%2F18%2FXcode%EF%BC%9A%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[在Xcode的库面板——代码片段库 中，可以添加自定义的使用率比较高代码块 添加方法： 通过快捷键(control+option+command+2)打开code snippet library, 在Xcode屏幕的右下角(Xcode改版后，版面发生了改变） 更改后的打开位置： 选中你的代码片段拖到code sniper library中,并设置title，快捷键，作用域 就是直接使用了，直接敲设置的快捷键就会弹出提示，直接回车就出出现你的代码片段 自己使用的如下： Title Completion Shortcut Code @property (strong) propertystrong @property (nonatomic, strong) &lt;#type#&gt; *&lt;#name#&gt;; @property (weak) propertyweak @property (nonatomic, weak) &lt;#type#&gt; *&lt;#name#&gt;; @property(assign) propertyassign @property (nonatomic, assign) &lt;#Type#&gt; &lt;#type#&gt; @property(block) propertyblock @property (nonatomic, copy) void(^&lt;#Type#&gt;)(&lt;#type#&gt;); @property(copy) propertycopy @property (nonatomic, copy) &lt;#Type#&gt; *&lt;#type#&gt; / / ss /&lt; &lt;#注释#&gt; &gt;/ #pragma mark pm #pragma mark - &lt;#delegate#&gt; //////// ff 分隔行 /////////////////////////////////////////////////////////////////////////////// /* / dd 多行注释 dd /** * &lt;##&gt; */ 创建单例 shareInstance + (instancetype)shareInstance { static dispatch_once_t onceToken; static id _singleton_; dispatch_once(&amp;onceToken, ^{ _singleton_ = [[self alloc] init]; }); return _singleton_; } block typefblock void (^&lt;#Title#&gt;)(&lt;#Type#&gt; &lt;#type#&gt;) = ^(&lt;#Type#&gt; &lt;#type#&gt;){ }; CollectionDataSource CollectionDataSource CollectionSource #pragma mark - UICollectionViewDataSource - (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section { return &lt;#NSInteger#&gt;; } - (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath { UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:cid forIndexPath:indexPath]; return cell; } - (NSInteger)numberOfSectionsInCollectionView:(UICollectionView *)collectionView { return &lt;#NSInteger#&gt;; } CollectionDelegate collectijonviewdelegate #pragma mark - collectionViewDelegate - (CGSize)collectionView:(UICollectionView *)collectionView layout:(UICollectionViewLayout*)collectionViewLayout sizeForItemAtIndexPath:(NSIndexPath *)indexPath{ return CGSizeMake(0, 0); } - (void)collectionView:(UICollectionView *)collectionView didSelectItemAtIndexPath:(NSIndexPath *)indexPath{ NSLog(@&quot;%ld&quot;,indexPath.row); } Notification Add na [[NSNotificationCenter defaultCenter] addObserver:&lt;#Observer#&gt; selector:&lt;#Selector#&gt; name:&lt;#Name#&gt; object:&lt;#Object#&gt;]; Notification Remove nr [[NSNotificationCenter defaultCenter] removeObserver:&lt;#Observer#&gt; name:&lt;#Name#&gt; object:&lt;#Object#&gt;]; NSLog log NSLog(@&quot;&lt;#Log#&gt;&quot;); Private Interface interface @interface &lt;#Title#&gt; () @end TableView createTableView tablesource #pragma mark - UITableViewDataSource - (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return &lt;#NSInteger#&gt;; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return &lt;#NSInteger#&gt;; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { return &lt;#UITableViewCell#&gt;; } Tableview分割线 tableviewseparate //view布局完子控件的时候调用 - (void)viewDidLayoutSubviews { //iOS7只需要设置SeparatorInset(iOS7开始有的)就可以了，但是iOS8的话单单只设置这个是不行的，还需要设置LayoutMargins(iOS8开始有的) if ([self.tableView respondsToSelector:@selector(setSeparatorInset:)]) { [self.tableView setSeparatorInset:UIEdgeInsetsMake(0,0,0,0)]; } if ([self.tableView respondsToSelector:@selector(setLayoutMargins:)]) { [self.tableView setLayoutMargins:UIEdgeInsetsMake(0,0,0,0)]; } } //cell即将展示的时候调用 - (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath { if ([cell respondsToSelector:@selector(setSeparatorInset:)]) { [cell setSeparatorInset:UIEdgeInsetsZero]; } if ([cell respondsToSelector:@selector(setLayoutMargins:)]) { [cell setLayoutMargins:UIEdgeInsetsZero]; } } weakSelf weak&amp;&amp;strong weak__ #define SHWeakSelf(type) __weak typeof(type) weak##type = type; #define SHStrongSelf(type) __strong typeof(type) type = weak##type;]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS小技巧总结]]></title>
    <url>%2F2016%2F10%2F11%2FiOS%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[参考iOS_小松哥的iOS小技巧总结 总结日常代码生活中的小技巧，随时可用 阿拉伯数字转中文格式阿拉伯数字转中文格式UITextField每四位加一个空格,实现代理 123456789101112131415161718192021- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; // 四位加一个空格 if ([string isEqualToString:@&quot;&quot;]) &#123; // 删除字符 if ((textField.text.length - 2) % 5 == 0) &#123; textField.text = [textField.text substringToIndex:textField.text.length - 1]; &#125; return YES; &#125; else &#123; if (textField.text.length % 5 == 0) &#123; textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text]; &#125; &#125; return YES;&#125; 禁止锁屏 默认情况下，当设备一段时间没有触控动作时，iOS会锁住屏幕。但有一些应用是不需要锁屏的，比如视频播放器。 123[UIApplication sharedApplication].idleTimerDisabled = YES;或[[UIApplication sharedApplication] setIdleTimerDisabled:YES]; iOS 获取汉字的拼音 12345678910111213+ (NSString *)transform:(NSString *)chinese&#123; //将NSString装换成NSMutableString NSMutableString *pinyin = [chinese mutableCopy]; //将汉字转换为拼音(带音标) CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformMandarinLatin, NO); NSLog(@&quot;%@&quot;, pinyin); //去掉拼音的音标 CFStringTransform((__bridge CFMutableStringRef)pinyin, NULL, kCFStringTransformStripCombiningMarks, NO); NSLog(@&quot;%@&quot;, pinyin); //返回最近结果 return pinyin; &#125; 手动更改iOS状态栏的颜色 123456789- (void)setStatusBarBackgroundColor:(UIColor *)color&#123; UIView *statusBar = [[[UIApplication sharedApplication] valueForKey:@&quot;statusBarWindow&quot;] valueForKey:@&quot;statusBar&quot;]; if ([statusBar respondsToSelector:@selector(setBackgroundColor:)]) &#123; statusBar.backgroundColor = color; &#125;&#125; NSArray 快速求总和 最大值 最小值 和 平均值 123456NSArray *array = [NSArray arrayWithObjects:@&quot;2.0&quot;, @&quot;2.3&quot;, @&quot;3.0&quot;, @&quot;4.0&quot;, @&quot;10&quot;, nil];CGFloat sum = [[array valueForKeyPath:@&quot;@sum.floatValue&quot;] floatValue];CGFloat avg = [[array valueForKeyPath:@&quot;@avg.floatValue&quot;] floatValue];CGFloat max =[[array valueForKeyPath:@&quot;@max.floatValue&quot;] floatValue];CGFloat min =[[array valueForKeyPath:@&quot;@min.floatValue&quot;] floatValue];NSLog(@&quot;%f\n%f\n%f\n%f&quot;,sum,avg,max,min); 修改UITextField中Placeholder的文字颜色 123[textField setValue:[UIColor redColor] forKeyPath:@&quot;_placeholderLabel.textColor&quot;];或 textField.tintColor = [UIColor redColor]; 关于NSDateFormatter的格式 123456789101112131415161718G: 公元时代，例如AD公元yy: 年的后2位yyyy: 完整年MM: 月，显示为1-12MMM: 月，显示为英文月份简写,如 JanMMMM: 月，显示为英文月份全称，如 Janualydd: 日，2位数表示，如02d: 日，1-2位显示，如 2EEE: 简写星期几，如SunEEEE: 全写星期几，如Sundayaa: 上下午，AM/PMH: 时，24小时制，0-23K：时，12小时制，0-11m: 分，1-2位mm: 分，2位s: 秒，1-2位ss: 秒，2位S: 毫秒 UIImage 占用内存大小 12UIImage *image = [UIImage imageNamed:@&quot;aa&quot;];NSUInteger size = CGImageGetHeight(image.CGImage) * CGImageGetBytesPerRow(image.CGImage); 图片上绘制文字 写一个UIImage的category 1234567891011121314151617181920212223242526272829- (UIImage *)imageWithTitle:(NSString *)title fontSize:(CGFloat)fontSize&#123; //画布大小 CGSize size=CGSizeMake(self.size.width,self.size.height); //创建一个基于位图的上下文 UIGraphicsBeginImageContextWithOptions(size,NO,0.0);//opaque:NO scale:0.0 [self drawAtPoint:CGPointMake(0.0,0.0)]; //文字居中显示在画布上 NSMutableParagraphStyle* paragraphStyle = [[NSParagraphStyle defaultParagraphStyle] mutableCopy]; paragraphStyle.lineBreakMode = NSLineBreakByCharWrapping; paragraphStyle.alignment=NSTextAlignmentCenter;//文字居中 //计算文字所占的size,文字居中显示在画布上 CGSize sizeText=[title boundingRectWithSize:self.size options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:[UIFont systemFontOfSize:fontSize]&#125;context:nil].size; CGFloat width = self.size.width; CGFloat height = self.size.height; CGRect rect = CGRectMake((width-sizeText.width)/2, (height-sizeText.height)/2, sizeText.width, sizeText.height); //绘制文字 [title drawInRect:rect withAttributes:@&#123; NSFontAttributeName:[UIFont systemFontOfSize:fontSize],NSForegroundColorAttributeName:[ UIColor whiteColor],NSParagraphStyleAttributeName:paragraphStyle&#125;]; //返回绘制的新图形 UIImage *newImage= UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage;&#125; 计算文件大小 12345678910111213141516171819202122232425262728293031323334353637//文件大小- (long long)fileSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; if ([fileManager fileExistsAtPath:path]) &#123; long long size = [fileManager attributesOfItemAtPath:path error:nil].fileSize; return size; &#125; return 0;&#125;//文件夹大小- (long long)folderSizeAtPath:(NSString *)path&#123; NSFileManager *fileManager = [NSFileManager defaultManager]; long long folderSize = 0; if ([fileManager fileExistsAtPath:path]) &#123; NSArray *childerFiles = [fileManager subpathsAtPath:path]; for (NSString *fileName in childerFiles) &#123; NSString *fileAbsolutePath = [path stringByAppendingPathComponent:fileName]; if ([fileManager fileExistsAtPath:fileAbsolutePath]) &#123; long long size = [fileManager attributesOfItemAtPath:fileAbsolutePath error:nil].fileSize; folderSize += size; &#125; &#125; &#125; return folderSize;&#125; 给UIView设置图片 123UIImage *image = [UIImage imageNamed:@&quot;image&quot;];self.MYView.layer.contents = (__bridge id _Nullable)(image.CGImage);self.MYView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5); 防止scrollView手势覆盖侧滑手势 1[scrollView.panGestureRecognizerrequireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer]; 获取私有属性和成员变量 #import 1234567891011121314151617181920//获取私有属性 比如设置UIDatePicker的字体颜色- (void)setTextColor&#123; //获取所有的属性，去查看有没有对应的属性 unsigned int count = 0; objc_property_t *propertys = class_copyPropertyList([UIDatePicker class], &amp;count); for(int i = 0;i &lt; count;i ++) &#123; //获得每一个属性 objc_property_t property = propertys[i]; //获得属性对应的nsstring NSString *propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; //输出打印看对应的属性 NSLog(@&quot;propertyname = %@&quot;,propertyName); if ([propertyName isEqualToString:@&quot;textColor&quot;]) &#123; [datePicker setValue:[UIColor whiteColor] forKey:propertyName]; &#125; &#125;&#125; 1234567891011121314//获得成员变量 比如修改UIAlertAction的按钮字体颜色 unsigned int count = 0; Ivar *ivars = class_copyIvarList([UIAlertAction class], &amp;count); for(int i =0;i &lt; count;i ++) &#123; Ivar ivar = ivars[i]; NSString *ivarName = [NSString stringWithCString:ivar_getName(ivar) encoding:NSUTF8StringEncoding]; NSLog(@&quot;uialertion.ivarName = %@&quot;,ivarName); if ([ivarName isEqualToString:@&quot;_titleTextColor&quot;]) &#123; [alertOk setValue:[UIColor blueColor] forKey:@&quot;titleTextColor&quot;]; [alertCancel setValue:[UIColor purpleColor] forKey:@&quot;titleTextColor&quot;]; &#125; &#125; 获取手机安装的应用 12345678910Class c =NSClassFromString(@&quot;LSApplicationWorkspace&quot;);id s = [(id)c performSelector:NSSelectorFromString(@&quot;defaultWorkspace&quot;)];NSArray *array = [s performSelector:NSSelectorFromString(@&quot;allInstalledApplications&quot;)];for (id item in array)&#123; NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;applicationIdentifier&quot;)]); //NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;bundleIdentifier&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;bundleVersion&quot;)]); NSLog(@&quot;%@&quot;,[item performSelector:NSSelectorFromString(@&quot;shortVersionString&quot;)]);&#125; 判断两个日期是否在同一周 写在NSDate的category里面 1234567891011121314151617- (BOOL)isSameDateWithDate:(NSDate *)date&#123; //日期间隔大于七天之间返回NO if (fabs([self timeIntervalSinceDate:date]) &gt;= 7 * 24 *3600) &#123; return NO; &#125; NSCalendar *calender = [NSCalendar currentCalendar]; calender.firstWeekday = 2;//设置每周第一天从周一开始 //计算两个日期分别为这年第几周 NSUInteger countSelf = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:self]; NSUInteger countDate = [calender ordinalityOfUnit:NSCalendarUnitWeekday inUnit:NSCalendarUnitYear forDate:date]; //相等就在同一周，不相等就不在同一周 return countSelf == countDate;&#125; 应用内打开系统设置界面 123//iOS8之后[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];//如果App没有添加权限，显示的是设定界面。如果App有添加权限（例如通知），显示的是App的设定界面。 获取WebView所有的图片地址 在网页加载完成时，通过js获取图片和添加点击的识别方式 12345678910111213141516171819//UIWebView- (void)webViewDidFinishLoad:(UIWebView *)webView&#123; //这里是js，主要目的实现对url的获取 static NSString * const jsGetImages = @&quot;function getImages()&#123;\ var objs = document.getElementsByTagName(\&quot;img\&quot;);\ var imgScr = &apos;&apos;;\ for(var i=0;i&lt;objs.length;i++)&#123;\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\ &#125;;\ return imgScr;\ &#125;;&quot;; [webView stringByEvaluatingJavaScriptFromString:jsGetImages];//注入js方法 NSString *urlResult = [webView stringByEvaluatingJavaScriptFromString:@&quot;getImages()&quot;]; NSArray *urlArray = [NSMutableArray arrayWithArray:[urlResult componentsSeparatedByString:@&quot;+&quot;]]; //urlResurlt 就是获取到得所有图片的url的拼接；mUrlArray就是所有Url的数组&#125; 123456789101112131415161718//WKWebView- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation&#123; static NSString * const jsGetImages = @&quot;function getImages()&#123;\ var objs = document.getElementsByTagName(\&quot;img\&quot;);\ var imgScr = &apos;&apos;;\ for(var i=0;i&lt;objs.length;i++)&#123;\ imgScr = imgScr + objs[i].src + &apos;+&apos;;\ &#125;;\ return imgScr;\ &#125;;&quot;; [webView evaluateJavaScript:jsGetImages completionHandler:nil]; [webView evaluateJavaScript:@&quot;getImages()&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,result); &#125;];&#125; 获取到webview的高度 1CGFloat height = [[self.webView stringByEvaluatingJavaScriptFromString:@&quot;document.body.offsetHeight&quot;] floatValue]; navigationBar变为纯透明 12345678//第一种方法//导航栏纯透明[self.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault];//去掉导航栏底部的黑线self.navigationBar.shadowImage = [UIImage new];//第二种方法[[self.navigationBar subviews] objectAtIndex:0].alpha = 0; navigationBar根据滑动距离的渐变色实现 123456789101112131415161718192021222324252627282930//第一种- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat offsetToShow = 200.0;//滑动多少就完全显示 CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [[self.navigationController.navigationBar subviews] objectAtIndex:0].alpha = alpha;&#125;//第二种- (void)scrollViewDidScroll:(UIScrollView *)scrollView&#123; CGFloat offsetToShow = 200.0; CGFloat alpha = 1 - (offsetToShow - scrollView.contentOffset.y) / offsetToShow; [self.navigationController.navigationBar setShadowImage:[UIImage new]]; [self.navigationController.navigationBar setBackgroundImage:[self imageWithColor:[[UIColor orangeColor]colorWithAlphaComponent:alpha]] forBarMetrics:UIBarMetricsDefault];&#125;//生成一张纯色的图片- (UIImage *)imageWithColor:(UIColor *)color&#123; CGRect rect = CGRectMake(0.0f, 0.0f, 1.0f, 1.0f); UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); CGContextSetFillColorWithColor(context, [color CGColor]); CGContextFillRect(context, rect); UIImage *theImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return theImage;&#125; iOS 开发中一些相关的路径 123456789101112131415模拟器的位置:/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs 文档安装位置:/Applications/Xcode.app/Contents/Developer/Documentation/DocSets插件保存路径:~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins自定义代码段的保存路径:~/Library/Developer/Xcode/UserData/CodeSnippets/ 如果找不到CodeSnippets文件夹，可以自己新建一个CodeSnippets文件夹。描述文件路径~/Library/MobileDevice/Provisioning Profiles navigationItem的BarButtonItem如何紧靠屏幕右边界或者左边界？ 一般情况下，右边的item会和屏幕右侧保持一段距离： 下面是通过添加一个负值宽度的固定间距的item来解决，也可以改变宽度实现不同的间隔： 12345678UIImage *img = [[UIImage imageNamed:@&quot;icon_cog&quot;] imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal];//宽度为负数的固定间距的系统itemUIBarButtonItem *rightNegativeSpacer = [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemFixedSpace target:nil action:nil];[rightNegativeSpacer setWidth:-15];UIBarButtonItem *rightBtnItem1 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];UIBarButtonItem *rightBtnItem2 = [[UIBarButtonItem alloc]initWithImage:img style:UIBarButtonItemStylePlain target:self action:@selector(rightButtonItemClicked:)];self.navigationItem.rightBarButtonItems = @[rightNegativeSpacer,rightBtnItem1,rightBtnItem2];]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字转中文]]></title>
    <url>%2F2016%2F09%2F27%2F%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97%E8%BD%AC%E4%B8%AD%E6%96%87%2F</url>
    <content type="text"><![CDATA[最近需要写一个阿拉伯数字转成汉字的功能，在网上搜到的资源都没有对小数进行处理，因此我做了一些小小的改动。不过，存在的问题是，对外部传入的NSString类型的参数有要求 1. 首个字符不能是“.”2. 不能输入两个小数点3. 保留到小数点后两位 这些限制可以放在textfield的代理方法中，在文章的最后我会给出限制的语句，可以直接使用。 现在在方法体中增加了对这些状况外条件的”适配”，妈妈再也不用担心了。不过如果你感到方法中代码太多，想在外部添加这些输入限制，可以使用/**/中的方法哦！反正都要去罗马😁当然，如果加上了这些代码后，下方代理中的方法就可以不添加了，不知道是不是简单一些呢(⊙o⊙)? 先上数字转汉字的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117+(NSString *)translation:(NSString *)arebic &#123; /* if (arebic.length == 0) &#123;//当字符串删除到空时，放回&quot;&quot; return @&quot;&quot;; &#125; NSString *str = arebic; BOOL isPoint = [arebic containsString:@&quot;.&quot;]; NSString *availStr; if (isPoint) &#123;//包含小数点 NSRange range =[arebic rangeOfString:@&quot;.&quot;]; str = [arebic substringToIndex:range.location]; availStr = [arebic substringFromIndex:(range.location+1)]; &#125; */ /// NSInteger pointLoc = -1; //当字符串删除到空时，放回&quot;&quot; || 数字输入有多个0 if ((arebic.length == 0) || ([arebic floatValue] == 0)) &#123; return @&quot;&quot;; &#125; NSString *str = arebic; BOOL isPoint = [arebic containsString:@&quot;.&quot;]; NSString *availStr; if (isPoint) &#123;//包含小数点 NSRange range =[arebic rangeOfString:@&quot;.&quot;]; pointLoc = range.location; //当第一个是点时 if (pointLoc == 0) &#123; str = @&quot;0&quot;; &#125; else &#123; str = [arebic substringToIndex:pointLoc]; &#125; availStr = [arebic substringFromIndex:(pointLoc+1)]; //防止出现多个小数点 if ([availStr containsString:@&quot;.&quot;]) &#123; availStr = [availStr stringByReplacingOccurrencesOfString:@&quot;.&quot; withString:@&quot;&quot;]; &#125; &#125; //防止出现多个0，如：0000098 NSInteger zeroCount = 0; for (int i = 1; i &lt; str.length+1; i++) &#123; NSString *subStr = [arebic substringToIndex:i]; NSLog(@&quot;%ld&quot;,[subStr integerValue]); if ([subStr integerValue] != 0) &#123; zeroCount = i-1; break; &#125; &#125; str = [str substringFromIndex:zeroCount]; /// NSArray *arabic_numerals = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;0&quot;]; NSArray *chinese_numerals = @[@&quot;一&quot;,@&quot;二&quot;,@&quot;三&quot;,@&quot;四&quot;,@&quot;五&quot;,@&quot;六&quot;,@&quot;七&quot;,@&quot;八&quot;,@&quot;九&quot;,@&quot;零&quot;]; NSArray *digits = @[@&quot;&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;万&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;亿&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;兆&quot;]; if (str.length &gt; digits.count) &#123;//防止数字超过兆导致崩溃 str = [arebic substringToIndex:digits.count]; &#125; NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals]; NSMutableArray *sums = [NSMutableArray array]; for (int i = 0; i &lt; str.length; i ++) &#123; NSString *substr = [str substringWithRange:NSMakeRange(i, 1)]; NSString *a = [dictionary objectForKey:substr]; NSInteger digitIndex = str.length -i-1; NSString *b = digits[digitIndex]; NSString *sum = [a stringByAppendingString:b]; if ([a isEqualToString:chinese_numerals[9]]) &#123; if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]]) &#123; sum = b; if ([[sums lastObject] isEqualToString:chinese_numerals[9]]) &#123; [sums removeLastObject]; &#125; &#125;else &#123; sum = chinese_numerals[9]; &#125; if ([[sums lastObject] isEqualToString:sum]) &#123; continue; &#125; &#125; [sums addObject:sum]; &#125; //解决现象，如：五百万零元的显示——&gt;五百万元 if (sums.count &gt; 1 &amp;&amp; [sums.lastObject isEqualToString:@&quot;零&quot;]) &#123; [sums removeLastObject]; &#125; if (isPoint &amp;&amp; availStr.length &gt; 0) &#123; [sums addObject:@&quot;点&quot;]; for (int i = 0; i &lt; availStr.length; i ++) &#123; NSString *substr = [availStr substringWithRange:NSMakeRange(i, 1)]; NSString *a = [dictionary objectForKey:substr]; [sums addObject:a]; &#125; &#125; [sums addObject:@&quot;元&quot;]; NSString *sumStr = [sums componentsJoinedByString:@&quot;&quot;]; NSString *chinese = [sumStr substringToIndex:sumStr.length]; // NSLog(@&quot;%@&quot;,str);// NSLog(@&quot;%@&quot;,chinese); return chinese;&#125; 可以直接对带有小数点的数字进行转换。 下方是对文字的限制代码：(下方仅供参考，使用了上方的代码块，这些限制统统不需要了) 12345678910111213141516171819202122232425262728293031323334353637/** * 需要避免 * * 1.首个字符不能是“.” * 2.不能输入两个小数点 * 3.保留到小数点后两位 * */- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string&#123; NSLog(@&quot;string------%@&quot;,string); NSLog(@&quot;textField******%@&quot;,textField.text); NSUInteger nDotLoc = [textField.text rangeOfString:@&quot;.&quot;].location; if ([string isEqualToString:@&quot;.&quot;]) &#123; //1.首个字符不能是“.” if (textField.text.length == 0) &#123; [self showError:@&quot;亲，第一个数字不能为小数点&quot;]; return NO; &#125; //2.限制只能输入一个小数点 if (NSNotFound != nDotLoc) &#123; [self showError:@&quot;亲，您已经输入过小数点了&quot;]; return NO; &#125; &#125; //3.有小数点时，不能超过小数点后两位 if (NSNotFound != nDotLoc &amp;&amp; range.location &gt; nDotLoc + 2) &#123; [self showError:@&quot;亲，您最多输入两位小数&quot;]; return NO; &#125; return YES;&#125; 附上代码github地址如果喜欢，欢迎star喔！！！😘:blush:]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
</search>
